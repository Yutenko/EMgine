<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>EMgine Editor (Core-only)</title>
  <!-- Nur Grund-CSS (volle Canvasfläche) -->
  <link rel="stylesheet" href="editor.css">
</head>

<body>
  <canvas id="canvas"></canvas>

  <!-- ======================
       Core (Engine/Plugins)
       Lade-Reihenfolge ist wichtig!
       ====================== -->
  <script src="core/core-base.js"></script>
  <script src="core/core-world.js"></script>
  <script src="core/core-camera.js"></script>

  <script src="core/core-grid.js"></script>
  <script src="core/core-history.js"></script>
  <script src="core/core-levels.js"></script>
  <script src="core/core-chunks.js"></script>
  <script src="core/core-underlay.js"></script>

  <!-- Core-Tools (UI-agnostisch) -->
  <script src="core/core-tool-paint.js"></script>
  <script src="core/core-tool-pan.js"></script>
  <script src="core/core-tool-selection.js"></script>

  <!-- Core-HUD/Overlay (optional) -->
  <script src="core/core-rulers.js"></script>

  <!-- Keybinds -->
  <script src="core/core-keybinds.js"></script>

  <!-- Renderer zuletzt (ordnet die Draw-Reihenfolge) -->
  <script src="core/core-render.js"></script>

  <script src="core/ecs.js"></script>
  <script src="core/components.js"></script>
  <script src="core/prefabs.js"></script>



  <script>
    (function () {
      function boot() {
        var canvas = document.getElementById('canvas');
        if (!canvas) {console.error('[boot] kein Canvas gefunden'); return;}

        // Editor-Startoptionen (Layernamen/Tints sind jetzt konfigurierbar)
        var editor = new Editor(canvas, {
          cols: 64, rows: 64, tileSize: 16, chunkTiles: 32,

          // Grid (Spacing standardmäßig 0 = keine Lücken)
          gridSpacing: 0,
          gridAlpha: 1,

          // Rulers (Lineale) – nur wenn core-rulers.js geladen ist
          rulersEnabled: true,

          // Konfigurierbare Tile-Layer (statt fix "floor/wall/...")
          tileLayers: ["tiles", "wall", "deco"],
          layerTints: {tiles: "#4FC3F7", wall: "#FF8A65", deco: "#BA68C8"},
          defaultLayer: "tiles"
        });

        // Core-Module registrieren (Reihenfolge beibehalten)
        editor
          .use(EditorWorld)
          .use(EditorCamera)
          .use(EditorGrid)
          .use(EditorHistory)
          .use(EditorLevels)
          .use(EditorChunks)
          .use(EditorUnderlay)

          // Tools (UI-agnostisch): deine Svelte-UI ruft deren API auf
          .use(EditorToolPaint)
          .use(EditorToolPan)
          .use(EditorToolSelection)

          // HUD/Overlay (optional)
          .use(EditorRulers)

          // Renderer zuletzt (ruft applyCamera → Underlay/Grid → Chunks → SelectionOverlay)
          .use(EditorRender);

        // Beispiel: anfängliche Brush/Tool-Konfiguration (optional)
        if (editor.setBrushId) editor.setBrushId(1);
        if (editor.setEraseButton) editor.setEraseButton(2); // Rechtsklick = Erase

        // nach Editor-Init:
        editor.use(EditorKeybinds);

        // Defaults
        editor.defineAction("paintPrimary", {mouseButton: 0});
        editor.defineAction("paintErase", {mouseButton: 2});
        editor.defineAction("panHold", {mouseButton: 1});
        editor.defineAction("toggleSelect", {key: "KeyS"});

        // Kontext-spezifische Extras
        editor.bindContext("boxSelect", "select", {mouseButton: 0, shift: true});
        editor.bindContext("addToSelection", "select", {mouseButton: 0, ctrl: true});

        // Kontexte aktivieren (Reihenfolge = Priorität)
        editor.pushContext("paint");
        editor.pushContext("select");

        // Optional: gespeicherte User-Profile laden/speichern
        var saved = localStorage.getItem("emg_keybinds_v2");
        if (saved) editor.importBindings(saved);
        editor.on && editor.on("keybinds:changed", function () {
          localStorage.setItem("emg_keybinds_v2", editor.exportBindings());
        });
        editor.on && editor.on("keybinds:conflict", function (e) {
          console.warn("Keybind-Konflikte:", e.conflicts);
        });

        // Für externe UIs (z. B. Svelte): Hook bereitstellen
        window.editor = editor;
        document.dispatchEvent(new CustomEvent('editor:ready', {detail: {editor: editor}}));
        console.log('[boot] editor ready');
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', boot);
      } else {
        boot();
      }


      /* ===========================
      * ECS / Components / Prefabs
      * =========================== */
      var ecs = ECS.create();
      registerStarterComponents(ecs);
      registerExamplePrefabs(ecs);

      // Entities erzeugen
      var e1 = ecs.prefabs.spawn(ecs.entities, {prefabId: "wall_thick", at: {x: 10, y: 5, level: 0}});
      var e2 = ecs.prefabs.spawn(ecs.entities, {prefabId: "floor_snow", at: {x: 10, y: 6, level: 0}});
      var e3 = ecs.prefabs.spawn(ecs.entities, {prefabId: "zone_hurt_lava", overrides: {Geometry: {params: {size: [3, 2]}}}, at: {x: 8, y: 4, level: 0}});
      var e4 = ecs.prefabs.spawn(ecs.entities, {prefabId: "door_wood", at: {x: 12, y: 5, level: 0}});

      // Zugriff auf Komponenten
      var g1 = ecs.components.get(e1, "Geometry");      // {type:"tile", shape:"thick", ...}
      var m1 = ecs.components.get(e1, "Material");      // {defaultTexture:"brick_01", ...}
      var p1 = ecs.components.get(e1, "Physics");       // {collidable:true,...}

      // Query: alle renderbaren Dinge (Geometry + Material)
      var renderIds = ecs.query.allWith(["Geometry", "Material"]);

      // Save/Load
      var saveData = ecs.serializer.save();
      console.log("Save Data:", saveData);

      // ... persistieren ...
      // ecs.serializer.load(saveData);  // (lädt Additiv – du kannst vorher resetten)

    })();
  </script>
</body>

</html>